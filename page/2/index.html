<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>stay hungry stay foolish</title>


<link rel="stylesheet" href="/styles/main.css">


    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">stay hungry stay foolish</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="/">主页</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/archives">归档</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="/about">关于</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
    <div class="posts-wrapper">
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/10/05/Cairo%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B/">Cairo知识简介</a>
            </div>
            <p class="sub">10月 05 2022</p>
            <div class="post-content">
                
                    <p> Cairo 是 STARK 证明系统的其中一个编程语言，让开发者能透过 Cairo 来使用 STARK，撰写效能更高的 DApp</p>
<h1 id="Cairo-编程语言："><a href="#Cairo-编程语言：" class="headerlink" title="Cairo 编程语言："></a>Cairo 编程语言：</h1><h2 id="设计理念："><a href="#设计理念：" class="headerlink" title="设计理念："></a>设计理念：</h2><p>Cairo 是一种通用的声明式编程语言，旨在使开发者能够更容易地编写复杂的智能合约和计算任务。</p>
<p>它采用了类似于函数式编程的方法，鼓励可复用的模块和组件。</p>
<h2 id="语法和特性："><a href="#语法和特性：" class="headerlink" title="语法和特性："></a>语法和特性：</h2><p>声明式编程：Cairo 强调了数据流和约束的概念，允许开发者更容易地表达问题的本质。</p>
<p>状态转换：Cairo 支持在合约中定义状态变量，这些变量可以在交易中被修改，从而允许合约执行状态转换。</p>
<p>零知识证明：Cairo 是零知识证明系统的一部分，它可以生成用于验证交易的证明，同时保护了交易的隐私。</p>
<p>标准库：Cairo 提供了一套丰富的标准库，包括加密学、哈希函数等常用的密码学原语，使得开发者可以轻松地实现复杂的加密功能。</p>
<h2 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h2><p>Cairo 不仅适用于智能合约的编写，还可以用于一般的计算任务，例如数据处理、模型训练等。</p>
<p>由于其通用性和灵活性，Cairo 可以用于各种需要高效、安全和隐私保护的计算场景。</p>
<h1 id="Cairo-在-StarkNet-上的作用："><a href="#Cairo-在-StarkNet-上的作用：" class="headerlink" title="Cairo 在 StarkNet 上的作用："></a>Cairo 在 StarkNet 上的作用：</h1><h2 id="StarkNet-架构："><a href="#StarkNet-架构：" class="headerlink" title="StarkNet 架构："></a>StarkNet 架构：</h2><p>Cairo 是 StarkNet 的核心编程语言之一，用于编写 StarkNet 合约。</p>
<p>StarkNet 提供了一个执行环境，使得 Cairo 合约可以在以太坊区块链上运行，并且可以利用以太坊的安全性和去中心化特性。</p>
<h2 id="合约部署和交互："><a href="#合约部署和交互：" class="headerlink" title="合约部署和交互："></a>合约部署和交互：</h2><p>开发者可以使用 Cairo 编写智能合约，并将其部署到 StarkNet 上，就像在以太坊上部署智能合约一样。</p>
<p>用户可以通过交易与部署在 StarkNet 上的 Cairo 合约进行交互，从而执行各种功能，如转账、数据查询等。</p>
<h2 id="性能优势："><a href="#性能优势：" class="headerlink" title="性能优势："></a>性能优势：</h2><p>StarkNet 利用了零知识证明技术，使得交易处理速度极快，可以处理大量的交易，同时保护了交易的隐私。</p>
<h1 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h1><p>StarkWare 提供了一套工具链，包括编译器、调试器等，来帮助开发者使用 Cairo 编写、测试和部署智能合约。</p>
<p>总的来说，Cairo 是 StarkNet 上的一种强大的编程语言，它的设计理念和特性使得开发者可以更轻松地构建复杂的智能合约和计算任务。通过 Cairo 和 StarkNet 的结合，开发者可以在以太坊区块链上构建高效、安全、隐私保护的去中心化应用程序。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/10/03/20221005%E9%9A%8F%E7%AC%94/">20221003随笔</a>
            </div>
            <p class="sub">10月 03 2022</p>
            <div class="post-content">
                
                    <p>终于完成搬家，陆陆续续搬3，4次，真是心力憔悴。</p>
<br/>

<p>30号入住那晚，我们下班后从老房子拉了一车东西，费力搬到楼上的时候已经1点了，在打整完厨房的物品已是3点多，匆忙洗漱睡觉，我和老婆都失眠了。</p>
<br/>

<p>第二天早上煮了一份汤圆算是正式开火，接着我又开车去老房子拉剩下的东西。扔东西真是提升幸福感的一大快事，但是总会有很多舍不得的东西，老房子塞满了我从毕业到现在的物品，塞满了我和老婆从认识到结婚的点点滴滴，也塞满了我爸留给我的回忆，我努力的做了N次扔和留的选择，最后又在塞完满满的一车之后，看着还剩下的几个大箱子，我选择了暂停，或许我该停下来静静，等过一段时间来在处理这些物品。开车走人</p>
<br/>

<p>昨天算是我们入住新家开启二人世界的第一天，老婆总是喜欢往府河边上逛，从我们搬家到现在已经陆陆续续去逛了4.5次了，我们绕着府河的绿道在走过喇叭桥，一路快步往前，一路有说有笑，像极了我们骑车上班下班的时候，路上总是不缺我两的欢声笑语，虽然偶尔会因为一些不愉快的事情相互沉默，但总归是少数。我有时候会想那些同行的骑车的人，开车的人，会不会觉得我俩是个傻子，骑个电瓶车开心个什么，哈哈，我们也不知道瞎开心什么，就是很开心。</p>
<br/>

<p>虽然有时候会很累，但是都挺值，为了我们未来，一路向前</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/09/20/Zk-STRAKs-VS-Zk-SNARKs/">Zk-STRAKs VS Zk-SNARKs</a>
            </div>
            <p class="sub">9月 20 2022</p>
            <div class="post-content">
                
                    <p>在不断发展的区块链领域，<a target="_blank" rel="noopener" href="https://hacken.io/discover/zero-knowledge-proof/">零知识证明</a>已成为最强大的加密技术，可提供更多隐私和可扩展性。也称为知识论证，它们生成某些计算具有特定输出的证明，同时非常快速地验证该证明。零知识（ZK）部分是额外的隐私奖励，可以隐藏一些计输入。</p>
<h1 id="零知识证明简介"><a href="#零知识证明简介" class="headerlink" title="零知识证明简介"></a>零知识证明简介</h1><p>零知识协议是一种使用 ZK 证明的方法，允许一方快速证明计算具有特定输出，而无需透露该计算的特定输入。需要证明和验证的秘密信息称为证人。</p>
<h2 id="它是如何运作的呢？"><a href="#它是如何运作的呢？" class="headerlink" title="它是如何运作的呢？"></a>它是如何运作的呢？</h2><p>ZK 证明由一些非常聪明但非常复杂的数学提供支持，我们仅在此概述。考虑一次大规模计算，我们使用输入数字对某些内容进行编码，然后对其进行哈希一百万次。“简洁”证明旨在验证计算中的特定输出，而无需镜像每个步骤。验证者通过随机抽样，只检查总部分的一小部分，而不是检查每个计算部分。如果这些检查通过，则假定整个计算可能是正确的。</p>
<h2 id="ZK-证明对于区块链的巨大价值"><a href="#ZK-证明对于区块链的巨大价值" class="headerlink" title="ZK 证明对于区块链的巨大价值"></a>ZK 证明对于区块链的巨大价值</h2><p>ZK 证明带来两个重要的好处：</p>
<ul>
<li><p>可扩展性：对于需要很长时间才能验证的区块，只有一个人可以进行计算并生成证明，例如 zk-SNAR 或 zk-STARK。其他网络参与者只需验证证明即可。</p>
</li>
<li><p>隐私：利用 ZK 隐藏计算输入使各方能够以增强的隐私进行交易，从而防止向公众泄露无关信息。例如，您可以验证余额中是否有足够的 ETH 进行购买，而无需暴露加密货币的原始发送者。</p>
</li>
</ul>
<p>由于这些强大的优势，zk-SNARKs 和 zk-STARs 等加密工具非常适合第 2 层可扩展性——可靠地确认链下转换，而无需在主网络上重新执行。</p>
<h1 id="ZK-SNARK-与-ZK-STARK"><a href="#ZK-SNARK-与-ZK-STARK" class="headerlink" title="ZK-SNARK 与 ZK-STARK"></a>ZK-SNARK 与 ZK-STARK</h1><p>zk-SNARK 和 zk-STARK 都指的是以真正高效且私密的方式验证证明的相同加密技术。然而，这两个工具的实现方式有所不同。SNARK 产生简洁且非交互式的证明，而 STARK 则产生可扩展且透明的证明。接下来我们将介绍其中的差异。</p>
<h2 id="什么是-zk-SNARK？"><a href="#什么是-zk-SNARK？" class="headerlink" title="什么是 zk-SNARK？"></a>什么是 zk-SNARK？</h2><p>zk-SNARK代表零知识简洁非交互式知识论证，是一种非交互式零知识证明，目前广泛用于构建零知识协议。像 Zcash 这样的隐私币使用它们来提供受保护的区块链体验，同时提供足够的证据来证明每笔受保护的交易都是有效的。</p>
<ul>
<li><p>ZK：这对代表“零知识”，表示该证明除了提交者声明的有效性之外不提供其他信息。任何描述交易性质、交易参与者和交换价值的信息都不会向验证者透露。</p>
</li>
<li><p>S：这个字母代表“简洁”，意味着证明尺寸很小（占用空间很小），为快速、轻松的验证铺平了道路。</p>
</li>
<li><p>N：代表非交互式，意味着证明者和验证者之间几乎不需要交互。从证明生成到提交和验证的一切都发生在单个交易中。</p>
</li>
<li><p>ARK：代表“知识论证”。这部分增加了计算可靠性的质量。简而言之，如果不具备支持其主张的知识（即通过持有他们试图伪造的底层信息），不良行为者很难欺骗基于 zk-SNARK 的系统。这是基于这样的理论：坏人的计算能力有限，这意味着任何拥有无限计算能力的人都可以创建虚假证明。一些 zk-SNARK 协议有办法防止这种攻击。</p>
</li>
</ul>
<p>一些 SNARK 的一个重要属性是它们要求配置过程是可信任的——在这个过程中，隐私交易的证明和生成证明的密钥会被创建。如果在事件期间用于创建这个密钥的秘密没有被销毁，它们可能被用来创建虚假证明。在涉及加密资产的场景中，这将使参与者能够伪造交易或凭空铸造新通证。由于 SNARKs 固有的隐私性，所以无法验证伪造的证明是否确实是伪造的。</p>
<p>SNARK 的安全级别是通过为找到虚假陈述的证据而必须完成的工作量来衡量的。换句话说，如果 SNARK 在计算上无法产生令人信服的虚假陈述证明，那么它就是安全的。对于需要可信设置才能被认为是安全的 SNARK，仪式中至少有一名参与者必须生成并销毁一个 trapdoor，如果与其他 trapdoor 结合使用的话，否则就有可能危及 SNARK 的安全性。因此，受信任的设置通常需要许多参与者一起运行，以使这种情况发生的可能性足够低。</p>
<h2 id="什么是-ZK-STARK？"><a href="#什么是-ZK-STARK？" class="headerlink" title="什么是 ZK-STARK？"></a>什么是 ZK-STARK？</h2><p>zk-STARK 全称 Zero-Knowledge Scalable Transparent Argument of Knowledge（零知识可扩展透明知识论证），是一种零知识证明系统，在 Eli Ben-Sasson、Iddo Bentov、Yinon Horesh 和 Michael Riabzev 于 2018 年发表的一篇<a target="_blank" rel="noopener" href="https://starkware.co/wp-content/uploads/2022/05/STARK-paper.pdf">论文</a>中作为 SNARK 的替代方案被引入。</p>
<ul>
<li><p>ZK：就像“zk-SNARKs”一样，这也意味着“零知识”，这意味着它们在不披露任何底层信息的情况下证明交易或交互，除非它们是正确和真实的。</p>
</li>
<li><p>S：这意味着“可扩展”，强调这些零知识证明如何专注于增强区块链的可扩展性。zk-STARK 使开发人员能够执行计算并在链外存储数据，从而以指数方式提高可扩展性。零知识证明验证这些链下活动，然后在线提交以供感兴趣的各方验证。</p>
</li>
<li><p>T：代表“透明”，这种品质标志着 zk-STARKs 和 zk-SNARKs 之间最显着的区别之一。他们使用公开可用的随机性来生成参数，从而无需可信设置。</p>
</li>
<li><p>ARK： “知识论证”的含义与之前相同，但使用了不同的计算方法。它使用抗冲突的哈希函数，有效地消除了对可信设置的需求。</p>
</li>
</ul>
<p>STARK 支持 StarkWare 的可扩展性技术。通过使开发人员能够在链下进行存储和计算，STARK 提高了可扩展性，因为验证链下计算准确性的 STARK 证明可以由链下服务生成，然后发布在链上。</p>
<p>STARK 允许区块链将计算转移到某个链下 STARK 证明者，然后使用链上 STARK 验证者验证这些计算的完整性。 Layer-2 网络可以通过使用 STARKs 在单个批次中计算大量交易，然后使用单个 STARK 证明来确认交易在链上的有效性，从而实现可扩展性。批次中的所有交易均分担链上操作的成本，为第 2 层网络上的每笔交易提供低 gas 成本。</p>
<h2 id="zk-SNARKs-与-zk-STARKs：相似点和不同点"><a href="#zk-SNARKs-与-zk-STARKs：相似点和不同点" class="headerlink" title="zk-SNARKs 与 zk-STARKs：相似点和不同点"></a>zk-SNARKs 与 zk-STARKs：相似点和不同点</h2><p>这两者有一些相似之处。首先，它们是尖端的非交互式零知识证明协议，证明者和验证者之间几乎不需要交互。证明生成、提交和验证通常在一笔交易内完成。</p>
<p>此外，它们还增强了区块链的可扩展性。零知识证明比平均比特币交易小得多，并且验证速度更快。快速验证和更少的区块空间意味着以太坊等网络具有更高的可扩展性。</p>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>zk-SNARKs 和 zk-STARKs 至少在四个主要点上有所不同：</p>
<p><img src="/images/6-1.png"></p>
<h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><p>在比较 zk-SNARK 与 zk-STARK 时，一个关键区别在于它们的透明度方法。zk-SNARK 需要一个初始可信设置阶段来生成生成零知识证明所需的随机性。这些参数通常由一小群人保管以保护它们。如果参数落入坏人之手，不诚实的行为者可能会利用它们来创建错误的证明。</p>
<p>zk-STARK 采用不同的方法，利用抗碰撞加密技术来消除私有参数生成仪式的需要。如果没有可信的设置，生成随机性的参数是公开的，限制了中心化并增强了透明度。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>zk-SNARKs 与 zk-STARKs 之间的另一个区别是它们的安全方法。零知识 SNARKS 使用初始设置来生成参数，并且根据其设置，计算上是合理的。然而，它们的可靠性是假设证明者的计算能力有限。然而，当证明者使用无限量的计算能力时，他们将能够使用某种算法，该算法可以执行极快的并行整数分解计算，该计算可用于从公钥中提取私钥。换句话说，他们将能够破坏证明系统。因此，理论上它们很容易受到量子计算攻击，因此不具备量子抗性。</p>
<p>zk-STARK 不需要初始可信设置，而是选择抗碰撞方法。因此，与它们的对应物不同，它们不需要很高的计算成本，从而消除了因量子计算的无限计算能力而受到损害的威胁。因此，它们的量子抗性等级更高。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>zk-STARK 的证明大小比 zk-SNARK 大得多，但是，zk-SNARK 的计算需求使其生成证明的速度比其他选项更慢。它们还比 zk-STARK 消耗更少的 Gas，并且由于字节大小的差异，它们验证证明的速度更快。</p>
<p>虽然 zk-SNARK 看起来由于证明验证速度更快而更具可扩展性，但 zk-STARK 生成证明的速度更快，扩展速度也更快，即使它们的证明大小更大。此外，由于采用了链下计算和存储，zk-STARK 在上链时消耗的 Gas 更少。然而，在低吞吐量期间（创建的证明很少），验证将需要更长的时间。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>zk-SNARK 建立在椭圆曲线上，在无法找到随机椭圆曲线元素相对于公共基点的离散对数的假设下，可以提高安全性和隐私性。</p>
<p>另一方面，zk-STARKs 使用精益加密技术（抗冲突哈希函数）来提供可扩展性和安全性。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>ZK-SNARK 的主要特点： </p>
<ul>
<li><p>数据可用性高，但可线性扩展。</p>
</li>
<li><p>非交互式计算的可能性。</p>
</li>
<li><p>zk-SNARK 的安全性取决于 CRS 设置。这里的错误会影响所有电路并允许生成错误证明。</p>
</li>
<li><p>ZK-SNARK 因其紧凑的证明大小和一致的验证时间而受到青睐，这使得它们在 ZK-rollups 中进行 L1 验证具有成本效益。</p>
</li>
</ul>
<p>ZK-STARK 的主要特点： </p>
<ul>
<li><p>无需初始可信设置。</p>
</li>
<li><p>非常畅销。特别是在处理大量数据时，它们的证明和验证时间比 zk-SNARK 慢。</p>
</li>
<li><p>证明尺寸越大，验证成本越高。</p>
</li>
<li><p>ZK-STARK 能够抵御量子计算威胁。</p>
</li>
</ul>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/30/Argentx%E9%92%B1%E5%8C%85%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/">Argentx钱包的介绍和使用</a>
            </div>
            <p class="sub">5月 30 2022</p>
            <div class="post-content">
                
                    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Argent X是 StarkNet 上最受欢迎且唯一的开源钱包，受到全球超过 300,000 人的信任。使用 Argent X，您可以购买加密货币并将其桥接到 StarkNet、交换代币、铸造和存储 NFT、玩区块链游戏等。ArgentX是浏览器插件钱包， Argent 是手机钱包</p>
<p>以太坊钱包分为两种，EOA 钱包和智能合约钱包。 EOA 就是我们常用的 Metamask 钱包。每个钱包对应一组助记词，每个地址有一个私钥。EOA 钱包简单易用，但易有安全风险。 智能合约钱包由代码生成的钱包。没有助记词，安全性高，功能更全，组合性好。StarkNet 上全部为智能合约钱包。</p>
<p>Argent X是一款浏览器扩展钱包，可让您轻松探索StarkNet 生态系统。 </p>
<p>创建 Argent X 帐户只需不到一分钟。只需从<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/argent-x/dlcobpjiigpikoobohmabehhmhfoodbb">Chrome</a>或<a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-GB/firefox/addon/argent-x/">Firefox</a>下载，然后完成快速入门流程，就可以立即访问测试网和StarkNet主网，从而与 StarkNet Dapp 进行交互。</p>
<h2 id="Argent-X有什么特点？"><a href="#Argent-X有什么特点？" class="headerlink" title="Argent X有什么特点？"></a>Argent X有什么特点？</h2><p>Argent X 钱包具有您所期望的 Metamask 等加密货币钱包的功能。 </p>
<ul>
<li><p>全球入口：使用 Ramp Network 或 Banxa，轻松将资金添加到您的钱包，费用低至美分，而不是美元 </p>
</li>
<li><p>来自其他网络的桥接资金：通过 Orbiter Finance 或 StarkGate 从其他网络（如以太坊、Polygon、Arbitrum 和 Optimism）转移加密货币或稳定币 </p>
</li>
<li><p>但与 Metamask 不同的是，Argent X 是一款智能钱包，它具有基于 StarkNet 构建的独特功能。 </p>
</li>
<li><p>欺诈监控：消除区块链交易的所有复杂性，并通过 Argent X 中关于每个操作结果的清晰沟通来防止攻击</p>
</li>
<li><p>交易审核：准确了解您与 Argent X 签署的内容并实时批准交易</p>
</li>
<li><p>一起批量处理事务：通过多重调用将事务捆绑到一个操作中</p>
</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h4 id="1-转至-Chrome-网上应用店，下载-Argent-X并将扩展程序添加到您的浏览器。"><a href="#1-转至-Chrome-网上应用店，下载-Argent-X并将扩展程序添加到您的浏览器。" class="headerlink" title="1. 转至 Chrome 网上应用店，下载 Argent X并将扩展程序添加到您的浏览器。"></a>1. 转至 Chrome 网上应用店，<a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/argent-x/dlcobpjiigpikoobohmabehhmhfoodbb">下载 Argent X</a>并将扩展程序添加到您的浏览器。</h4><p><img src="/images/7-1.png"></p>
<h4 id="2-点击（Create-a-new-wallet）创建钱包，并选择一组密码。"><a href="#2-点击（Create-a-new-wallet）创建钱包，并选择一组密码。" class="headerlink" title="2. 点击（Create a new wallet）创建钱包，并选择一组密码。"></a>2. 点击（Create a new wallet）创建钱包，并选择一组密码。</h4><p><img src="/images/7-2.png"></p>
<h4 id="3-阅读免责声明，然后单击“继续”"><a href="#3-阅读免责声明，然后单击“继续”" class="headerlink" title="3. 阅读免责声明，然后单击“继续”"></a>3. 阅读免责声明，然后单击“继续”</h4><p><img src="/images/7-3.png"></p>
<h4 id="4-创建密码，请尽量复杂一点"><a href="#4-创建密码，请尽量复杂一点" class="headerlink" title="4. 创建密码，请尽量复杂一点"></a>4. 创建密码，请尽量复杂一点</h4><p><img src="/images/7-4.png"></p>
<h4 id="5-备份你的助记词，点击Save-your-recovery-phrase，手写下单词组"><a href="#5-备份你的助记词，点击Save-your-recovery-phrase，手写下单词组" class="headerlink" title="5. 备份你的助记词，点击Save your recovery phrase，手写下单词组"></a>5. 备份你的助记词，点击Save your recovery phrase，手写下单词组</h4><p><img src="/images/7-5.png"></p>
<h4 id="请开始你的Starknet网络之旅吧"><a href="#请开始你的Starknet网络之旅吧" class="headerlink" title="请开始你的Starknet网络之旅吧"></a>请开始你的Starknet网络之旅吧</h4>
                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/05/23/StarkNet%E5%8E%9F%E7%94%9F%E6%8A%BD%E8%B1%A1%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/">StarkNet原生抽象账户模型</a>
            </div>
            <p class="sub">5月 23 2022</p>
            <div class="post-content">
                
                    <h1 id="账户是什么？"><a href="#账户是什么？" class="headerlink" title="账户是什么？"></a>账户是什么？</h1><p>以太坊最基础的双账户为：外部账户与合约账户。</p>
<p><strong>外部帐户</strong>（Externally Owned Account，EOA）作为我们与区块链互动的切入点，我们持有一组公私密钥来控制这个 EOA，而全局对应的地址会记录在链上，同时记录着该组地址的状态（如Balance、Nonce等）。</p>
<p><strong>合约账户</strong>（Contract Account, CA）简单来说就是存了钱的智能合约，是另外一种储存我们资产的方式。我们能够利用智能合约的合约性和签章的判断使（合约）账户更重要，完成以及人群的特点。</p>
<h1 id="什么是抽象账户？"><a href="#什么是抽象账户？" class="headerlink" title="什么是抽象账户？"></a>什么是抽象账户？</h1><p>更深入的说，过去节点会负责验证交易、收费手续费、使用ECDSA验证标签，抽象账户把这些东西拉到智能合约中变成合约合约码的一部分，就能够本身进行编程。所以，实现抽象目标有一个目标：「有一个完善的、能正确的验证交易，且将用户交易分配上链的智能合约系统设计」。</p>
<p>帐户抽象作为解决中心化交易所的安全性和助记词的复杂性，能让钱包达到甚至超出 Web2 用户对使用体验的期待，例如，使用人脸识别或双重验证签署交易。它促进了帐户分类和支付限制；最终实现简易帐户恢复并移除全部助记词。这就是对用户页面和用户体验的革新。</p>
<h1 id="ERC-4337"><a href="#ERC-4337" class="headerlink" title="ERC-4337"></a>ERC-4337</h1><p>除了 EOA 之外，以太坊还拥有合约，其中包含用户定义的代码。2023 年，以太坊推出了一项协议升级 — ERC-4337，目的是在不引入重大协议变更的情况下，弥合 EOA 和合约之间的结构差距。ERC-4337 的主要理念是引入一个新角色：Bundler。Bundler 的作用是收集用户操作（将它们视为在专门的内存池中收集的元交易），并通过他们自己的 EOA（由 Bundler 控制）将这些用户操作发送到以太坊。通过这种方式，Bundler 允许开发者和用户部署并交互帐户合约，从而获取帐户抽象的优势。</p>
<p>通过 ERC-4337 将帐户抽象引入以太坊，使开发者能够为合约创建更灵活的行为。然而，以太坊仍然会继续维护 EOA。对于开发者来说，这样做的后果是必须同时服务 EOA 和 ERC-4337。在 EOA 成本更低的生态系统中，可以预见 EOA 将继续占据主导地位，应用程序将无法在整个用户群体中收获帐户抽象的实际价值。</p>
<h1 id="Starknet-的原生帐户抽象"><a href="#Starknet-的原生帐户抽象" class="headerlink" title="Starknet 的原生帐户抽象"></a>Starknet 的原生帐户抽象</h1><p>相比之下，Starknet 将帐户抽象作为其核心，即所有的帐户都是智能帐户。Starknet 没有 EOA，而是直接跃入每个帐户都是智能帐户的世界。所有的基础设施，包括钱包和区块浏览器，都是为帐户抽象而设计并构建的。这在所有 L1 和 L2 链中都是独一无二的，这使 Starknet 成为第一个智能生态系统：建设者们可以在知道帐户抽象适用于所有帐户的情况下构建自己的应用程序和工具，而无需为非帐户抽象的帐户工作并提供服务。建设者们可以设计他们的应用程序，从帐户抽象所提供的各种机会中受益，因为他们知道智能帐户是用户与应用程序交互的唯一方式。</p>
<p>Starknet 上的原生帐户抽象消除了因引入 Bundler（如 ERC-4337 所做的那样）所带来的额外复杂性。无需调整基础设施和工具来与 Bundler 进行交互，而是通过指定排序器来履行 Bundler 的角色，从而简化这个流程。</p>
<p>帐户抽象的三大特点</p>
<p>帐户抽象主要包括三个组成部分，分别是签名抽象、费用抽象和 Nonce 抽象。每个部分都有其独特的作用，来提升整体用户体验。</p>
<h2 id="签名抽象"><a href="#签名抽象" class="headerlink" title="签名抽象"></a>签名抽象</h2><p>签名抽象设计交易流程，让定义有效交易的权力掌握在架构师，即帐户设计者手中，无论这个人是开发者还是用户。这样做的主要好处在于可以自定义帐户权限，并使得使用智能手机控制帐户成为可能。</p>
<h2 id="费用抽象"><a href="#费用抽象" class="headerlink" title="费用抽象"></a>费用抽象</h2><p>费用抽象允许使用不同的代币来支付交易费用，而不局限于网络原生代币。例如，用户可以直接使用 USDC 支付交易费，而无需先将 USDC 兑换成本地代币，从而节省了兑换费用和时间。</p>
<h2 id="Nonce-抽象"><a href="#Nonce-抽象" class="headerlink" title="Nonce 抽象"></a>Nonce 抽象</h2><p>Nonce 抽象确保了用户的舒适性和便利性。传统的顺序 nonce 解决方案存在一些用户体验缺陷。例如，由于需要强制执行完整排序，就会限制用户同时发送多个独立交易。Nonce 抽象通过允许自定义帐户的重放保护机制来提供所需的灵活性。</p>
<h1 id="恢复机制"><a href="#恢复机制" class="headerlink" title="恢复机制"></a>恢复机制</h1><p>一个帐户实际上有 2 个公钥：硬件签名器公钥，用于签署所有交易；另一个是从助记词派生的密钥，它只能用于签署「请求删除硬件签名器」这一交易。此请求不会立即执行，而是有 4 天的延迟（可配置），让用户可以使用硬件签名器取消此类请求。这意味着如果设备被盗&#x2F;丢失&#x2F;无法使用，用户仍然可以在四天内恢复帐户。但是，如果助记词被盗，并且攻击者发出删除硬件签名器的请求，用户设备会自动（且重复）收到通知，且能够取消请求并保证资产安全。</p>
<h1 id="StarkNet钱包项目"><a href="#StarkNet钱包项目" class="headerlink" title="StarkNet钱包项目"></a>StarkNet钱包项目</h1><h2 id="Braavos"><a href="#Braavos" class="headerlink" title="Braavos"></a>Braavos</h2><p>Braavos 团队使用 Starknet 原生智能帐户创建了一款智能钱包，这种钱包能够提供类似 Web 2 的体验，让您可以使用手机的生物识别功能来访问你的钱包。这是一件令人兴奋的事情！大多数区块链所使用的加密技术与移动设备使用的加密技术存在差异，这通常会导致极高的签名验证成本。而未来，在保持高级别的安全性前提下，使用手机签署交易也许会成为可能。</p>
<p><img src="/images/3-1.png"></p>
<h2 id="Argent"><a href="#Argent" class="headerlink" title="Argent"></a>Argent</h2><p>通过使用签名抽象，ArgentX 的监护服务 Argent-Shield 带来了另一项创新。这项服务通过让 Argent 充当监护人，让用户为自己的帐户增加了一层保护。只有通过邮件确认的交易才会被 Argent 批准。这是我们熟悉的另一种双因素身份验证机制，通常应用于许多非区块链应用程序中。</p>
<p><img src="/images/3-2.png"></p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/03/05/Rullups%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/">Rullups技术详解</a>
            </div>
            <p class="sub">3月 05 2022</p>
            <div class="post-content">
                
                    <h1 id="什么是Rullups？"><a href="#什么是Rullups？" class="headerlink" title="什么是Rullups？"></a>什么是Rullups？</h1><p>总的来说Rullups就是通过将以太坊交易的成本加上汇总用户之间批量交易的较小成本来减少费用。它们还加速了事情的发展：汇总速度非常快，并且以太坊区块链只需要处理一笔交易而不是几笔交易。这很有用，因为以太坊的独立交易速率约为每秒 15 笔交易。</p>
<p>为了解决以太坊拥堵和gas消耗过高的问题，链上改进方案中包括了扩展区块大小、改变共识算法、分片等等。虽然链上的改进方案在当前的区块链技术发展阶段还没有完全展现出在提升效率上的实力(如ETH2.0的分片还在开发中)，但其都无法改变在区块链上为了安全性必须要承受冗余存储和计算的约束的现状。而这一约束可以被链下的改进方案打破。将存储和计算转移到链下，并设计机制保障链下存储和计算的可信与安全是链下扩展方案的核心。Rollup就是链下方案中的一类。</p>
<h1 id="Rollup的演进"><a href="#Rollup的演进" class="headerlink" title="Rollup的演进"></a>Rollup的演进</h1><p><img src="/images/2-1.png"></p>
<p>最早的Layer2是侧链技术，其发展一直不温不火，最近由于Polygon的崛起引来了很多讨论。但，如Polygon一类的侧链的运行基础是信任 一组验证者，这类有强信任假设的方案，在没有易用的无信任假设的方案诞生前，可以被作为一种折中方案应用，但绝不是最终的最优方案。另外，业界对于将侧链归类于Layer2是持怀疑甚至是质疑态度的，原因在于侧链不会保持向主链同步状态变更，更接近一条独立的链，一个新的Layer1。</p>
<p>闪电网络是最早的尝试无信任假设的Layer2解决方案之一。他通过RSMC和HTLC技术分别解除了对交易对手方的信任依赖和对资金路由节点的信任依赖。即，用户无需假定交易对手方和转发资金的中间节点是不会作恶的。但是这种方案在安全性、易用性、通用性上都付出了代价 ，限制了该项技术的应用推广。</p>
<p>Plasma是闪电网络之后出现的技术。其模型兼有侧链和闪电网络的特点。Plasma与闪电网络的不同在于链下交易的传递、组织和提交形式。闪电网络链下交易的传递基于以状态通道连接而成的网络，交易存储在交易双方的状态通道中，通道中的交易对手方均可自行提交通道中的交易带来的状态变更。但Plasma选择了与侧链更为接近的交易传递和组织形式，会有Layer2的运营者负责接收交易、组织存储(在Plasma Cash方案中，需要用户自己存储一部分交易信息)和将状态变更提交上链。然而，侧链是基于信任的模式，用户侧链上的运营者(或者说矿工)不作恶。在去信任化上，Plasma沿袭了闪电网络使用欺诈证明的思想，通过设置挑战期和激励博弈来防止作恶。但是，Plasma同样存在安全性、易用性、通用性上的问题，现今基本是一条已经被放弃作为独立Layer2的技术路线。</p>
<p>Rollup方案仍然保留了Plasma借用二层的运营者来接收、存储和提交状态变更的思想，但考虑到此前方案中将数据存储在链下的思路衍生出了安全性和易用性问题，而直接将数据存储在链上无法实现效率提升，因此诞生了将数据压缩上链的思路。交易数据上链后最直接解决的是用户易用性的问题，链上的数据是公开透明的，意味不再需要为了防欺诈而要求用户做出一些十分伤害体验的行为，如保持一定的上线频率以及自行保存用于自证清白的数据(闪电网络和Plasma都有此要求)。同时，数据上链也间能接解决了一些可能衍生的安全问题，如闪电网络瞭望塔隐私泄露、Plasma上的批量退出等在Rollup的场景下是不需要被考虑的。</p>
<h1 id="Rollup技术核心要点"><a href="#Rollup技术核心要点" class="headerlink" title="Rollup技术核心要点"></a>Rollup技术核心要点</h1><p>虽然不同Rollup的具体实现会不一样，但均需要解决三个共性的问题：如何实现交易压缩、如何将二层的状态转换同步到一层以及如何保证二层运营者如实提交了二层的所有状态转换。我们将在下面三个小节分别讨论。</p>
<h2 id="如何实现交易压缩？"><a href="#如何实现交易压缩？" class="headerlink" title="如何实现交易压缩？"></a>如何实现交易压缩？</h2><p>关于为什么要将数据上链，在上一章中已经有阐述。上链后，二层交易数据在链上的数据可用性(或者说数据有效性、数据可获得性)能得到保障。但数据如果原样上链，是难以达到通过二层提升效率的目的的，所以会进行压缩。讲到压缩，大家通常的理解是对占用字节数的压缩，也就是体积上的压缩，其实不然。压缩主要是对交易消耗Gas数的压缩，因为以太坊上的区块限制是以Gas为限制而不是字节数，更小的字节数对应着更小的存储占用，但不等同于更小的Gas消耗。Rollup中的压缩，一方面确实压缩了交易占用的字节数，另一方面也会减少交易执行的计算量以降低Gas消耗。</p>
<h2 id="如何将二层的状态转换同步到一层？"><a href="#如何将二层的状态转换同步到一层？" class="headerlink" title="如何将二层的状态转换同步到一层？"></a>如何将二层的状态转换同步到一层？</h2><p>上一小节在讲交易压缩时提到二层运营者除了提交交易信息外，还会提交批次交易发生前后的状态根。这个状态根与以太坊一层的状态树的状态根类似，是账户状态的归集。</p>
<p>Rollup的状态可以用Merkle树来组织，叶子节点为账户状态，中间节点存放层层向上进行哈希计算的信息，根节点是最终的哈希值，是二层所有账户状态的摘要。二层的交易会改变交易相关的账户的状态，引起叶子节点的信息变动，最终导致根哈希值的变动。二层的运营者会在本地维护二层账户的状态树，记录批次交易发生前后的根哈希值，在上传批次交易时将此二哈希值一并上传。</p>
<h2 id="如何防止二层运营者欺诈？"><a href="#如何防止二层运营者欺诈？" class="headerlink" title="如何防止二层运营者欺诈？"></a>如何防止二层运营者欺诈？</h2><p>Rollup诞生之前的闪电网络和Plasma采用的均是欺诈证明的方式，而Op系技术承袭二者思想同样使用了该方式。即，在运营者提交信息时不做关于状态转换合法性的校验，但是会为该批次的交易的提交预留挑战期。如果在挑战期内，无人对其合法性做出挑战则交易被确认；若有，则挑战者需提供欺诈证明，证明运营者作恶。</p>
<p>欺诈证明是相对容易的实现方式(相比后面要提到的有效性证明)，但带来的代价是用户体验和资金效率的牺牲。在没有保证链上数据有效性的闪电网络和Plasma的方案中，需要用户保证一定的在线频率(也叫做用户活性)来防止欺诈，同时，用户资金无法及时取出需要等待挑战期结束。在Optimistic Rollup下，虽然也是使用欺诈证明，但对用户体验和资金效率伤害的情况有所改善。由于数据上链，挑战者可以由除用户外的第三方提交，降低了对用户活性的假设大幅改善体验。另外，Op方案下，虽然仍然存在挑战期，但是对于非欺诈的交易，交易的最终性是可以预期的，Op的使用者可以自行搭建验证节点快速验证交易合法性而不必等到挑战期结束，虽然交易仍然要等到挑战期结束后才能被主链确认，但其最终性可以被快速确认，利用这一点流动性提供商可以提前为用户释放资金流动性。不过，这种解决方案并不是内嵌在Op之中，需要依赖应用解决方案</p>
<h1 id="ZK-Rollups"><a href="#ZK-Rollups" class="headerlink" title="ZK Rollups"></a>ZK Rollups</h1><p>ZK Rollups, ZKSnark 或者叫 Zero Knowledge Rollups，顾名思义，通过零知识证明验证来进行 Rollups 环节。零知识证明，也是区块链公链项目 Algorand 的创始人 Silvio Micali 在密码学的主要贡献之一。</p>
<p><img src="/images/2-2.png"></p>
<p>ZK 的四大特点：</p>
<ol>
<li><p>Zero Knowledge: 验证者无需看到交易平台有数据</p>
</li>
<li><p>Succinct: 言简意赅的，简练的</p>
</li>
<li><p>Non-Interactive: 无需知道验证者是谁</p>
</li>
<li><p>Argument of Knowledge: 证明交易的真实性与正确性</p>
</li>
</ol>
<p>所以 Zk Rollups 的核心方法，即通过严谨复杂的验证算法，Layer 2 协议中的验证者（ZkSnarker&#x2F; Validator）来认证不同数据的真实性 (Validity Proof)，从而将认证结果打包。以太坊网络排除多余工作信息后，可以直接将存有大量压缩签名信息的数据 block 吸收进网络。</p>
<p>任何人都可以参与网络认证，成为认证者，所以，本质上来说，ZKSnark 也是一种 PoW 共识机制的 Layer 2 协议。</p>
<p>【优点】：</p>
<p>Layer 2 被以太坊验证的速度很快，可以很快把存在 Layer 2 的资产，提币回 Layer 1 以太坊。很适合应用在 Payment，银行，交易平台等需要快速结算的业务</p>
<p>【缺点】：</p>
<p>由于算法较为复杂，对应用开发有点门槛。但如果未来能基于算法，开发出对 Dapp 更友好的模式，ZK 还是最具有长期扩容价值的方法</p>
<h1 id="Optimistic-Rollups"><a href="#Optimistic-Rollups" class="headerlink" title="Optimistic Rollups"></a>Optimistic Rollups</h1><p>Optimistic 的方法如其名字的意思：乐观的，开始认为所有发送的交易都是值得信赖认证过的，Layer 2 验证者需要先质押 Token 作为保证金，如果验证过程中，别人发现了有问题的打包，那么该验证者（Sequencer）将被罚款部分 Token，并把其作为奖励给与发现问题的人。每次数据打包后，会有验证期，以供其他验证者检查是否有问题，是否需要重新退回打包。</p>
<p><img src="/images/2-3.png"> </p>
<p>Op Rollups 与 ZK Rollups 方法本质的区别是，ZK 所有人都可以参与通过 PoW 认证来参与认证，而 OP 里面更倾向于选择一组值得信赖的认证者，监督整个打包交易的过程。</p>
<p>【优点】：</p>
<p>适合开发 Dapp，可以几乎无缝迁移原本在 Layer 1 的项目，同时也在开发相应的 OVM 虚拟机</p>
<p>【缺点】：</p>
<p>Layer 2 提币到 Layer 1 的速度较慢，通常需要 1 周以上（因为需要给验证者验证打包的真实性）但目前正在有优化的补充协议帮助加速此种模式的速度。有验证者作恶的风险成本。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/02/24/starknet%E4%BB%8B%E7%BB%8D/">starknet介绍</a>
            </div>
            <p class="sub">2月 24 2022</p>
            <div class="post-content">
                
                    <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>StarkNet 是一个解决区块链可扩展性挑战的尖端解决方案。StarkNet 是一个无需许可的去中心化有效性汇总，也称为 zk-rollup，构建在以太坊网络上。</p>
<p>它作为第 2 层解决方案，允许去中心化应用程序 (DApp) 实现其计算的无限可扩展性，同时保持以太坊生态系统的可组合性和安全性。StarkNet 利用 STARK（可扩展透明知识论证）技术的强大功能，这是现有的最安全、最可扩展的加密证明系统之一。</p>
<p>通过使用 STARK，StarkNet 可以验证交易和计算，而不需要所有网络节点验证每个操作。这显着减少了计算负担并增加了区块链网络的吞吐量。</p>
<p>借助 StarkNet，开发人员可以在以太坊上构建和部署具有高计算要求的复杂应用程序，而无需担心可扩展性限制。未来看起来充满希望，因为 StarkNet 在释放去中心化应用程序的全部潜力并将区块链带入主流方面发挥着至关重要的作用。</p>
<p>凭借其灵活性和先进功能，开发人员可以利用 Cairo 语言并利用 StarkNet 的高吞吐量和可定制性来构建创新和定制的 DApp。</p>
<h1 id="StarkNet-背后的技术"><a href="#StarkNet-背后的技术" class="headerlink" title="StarkNet 背后的技术"></a>StarkNet 背后的技术</h1><p>StarkNet 使用名为 zk-STARKs 的先进技术来实现作为第 2 层解决方案的可扩展性。</p>
<p>那么，什么是 zk-STARK？它们是 StarkWare 开发的加密创新，在维护区块链计算的完整性和隐私方面发挥着至关重要的作用。Zk-STARK 允许区块链将复杂的计算从链下转移到单个 STARK 证明者，该证明者生成加密证明。然后，这些证明由 STARK 验证者在链上进行验证，以保证计算的正确性。</p>
<p>为了使 zk-STARKs 实用化，StarkWare 将现代代数与经过实战检验的哈希函数相结合。该组织在准线性 PCP、交互式预言证明 (IOP) 和快速代数编码协议（如 FRI）等领域取得了重大突破。</p>
<p>这使得他们的 STARK 证明器和验证器成为同类中最快的，优于其他加密结构。值得注意的是，该技术依赖于更少、更安全的加密假设，并且可以抵御量子攻击。它也是透明的，这意味着它在设置过程中不使用有风险的加密元素，并且没有隐藏的漏洞。</p>
<p>StarkNet 提供了一个强大的平台，可以高效且经济高效地处理智能合约。它通过不同组件的组合来实现这一目标，每个组件在生态系统中都发挥着至关重要的作用。</p>
<p><img src="/images/4-1.png"></p>
<h3 id="合约注册："><a href="#合约注册：" class="headerlink" title="合约注册："></a>合约注册：</h3><p>合约注册表是 StarkNet 上部署的所有智能合约的记录保存者。它维护了这些合约的完整列表，使访问它们和与它们交互变得容易。它就像一个目录，可以帮助您找到想要使用的合适合同。</p>
<h3 id="ZK操作者："><a href="#ZK操作者：" class="headerlink" title="ZK操作者："></a>ZK操作者：</h3><p>ZK操作者是ZK证明的主要。它生成这些交易证明并将其发送到执行管理器。此外，它还管理一种称为 Merkle 树的特殊类型的数据结构，用于创建这些证明。ZK 操作者确保证明生成准确且可信。</p>
<h3 id="执行管理（EM）"><a href="#执行管理（EM）" class="headerlink" title="执行管理（EM）:"></a>执行管理（EM）:</h3><p>将执行管理为 StarkNet 管弦乐队的指挥。它管理智能合约的执行并处理交易。每当交易发生时，EM 都会相应地更新网络状态。它确保一切顺利和谐地进行。</p>
<h3 id="验证者："><a href="#验证者：" class="headerlink" title="验证者："></a>验证者：</h3><p>验证者就像一位侦探，具有敏锐的眼光来辨别真实性。它验证用户创建的 ZK（零知识）证明。这些证据对于保持已执行合同的准确性和完整性至关重要。验证者检查证明的输入是否满足合同的条件，确保一切都是合法的。</p>
<h1 id="Cairo-编程语言："><a href="#Cairo-编程语言：" class="headerlink" title="Cairo 编程语言："></a>Cairo 编程语言：</h1><p>StarkNet 是使用 Cairo 编程语言构建的。该语言针对 zk-STARKs（一种加密证明系统）进行了明确优化。Cairo 使开发人员能够编写复杂且安全的智能合约。它提供了一个框架，允许开发人员在将合约部署到 StarkNet 网络之前在本地测试其合约，从而保证可靠性和效率。</p>
<h3 id="证明验证者工厂："><a href="#证明验证者工厂：" class="headerlink" title="证明验证者工厂："></a>证明验证者工厂：</h3><p>证明验证器工厂就像一个在需要时生产验证器的工厂。它负责创建新的验证者并管理其生命周期。它确保系统有足够的验证者来有效地处理验证过程。</p>
<h3 id="存储："><a href="#存储：" class="headerlink" title="存储："></a>存储：</h3><p>StarkNet 有一个存储层，用于存储智能合约和检索数据。该存储层基于 Merkle 树，这是一种高效的数据结构。它允许快速、轻松地访问合约相关信息，使与智能合约的交互更快、更顺畅。</p>
<h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>该网关充当以太坊和 StarkNet 之间的桥梁。它允许用户使用以太坊网络从 StarkNet 存入和提取资金。这种连接使用户可以方便地在两个平台之间转移资产，并受益于 StarkNet 提供的优势。</p>

                
            </div>
        </article>
    
        <article class="post article-entry">
            <div class="post-title">
                <a class="post-title-link text-underline" href="/2022/01/05/%E4%BB%A5%E5%A4%AA%E5%9D%8AL2%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/">以太坊L2扩展方案对比</a>
            </div>
            <p class="sub">1月 05 2022</p>
            <div class="post-content">
                
                    <h2 id="为什么需要L2？"><a href="#为什么需要L2？" class="headerlink" title="为什么需要L2？"></a>为什么需要L2？</h2><p>这得聊到区块链不可能三角，也就是当前区块链的技术限制，在去中心化，可拓展性，和安全性中只能得其二<br><img src="/images/1-1.png"></p>
<h3 id="（一）选择去中心化与安全性"><a href="#（一）选择去中心化与安全性" class="headerlink" title="（一）选择去中心化与安全性"></a>（一）选择去中心化与安全性</h3><p>比特币作为案例。比特币通过加密算法和完全分布式的验证机制实现了安全性和去中心化。但是缺陷也很明显，因为要分布式的验证，比特币每秒只能处理7笔交易，比起传统中心化机构的百万级处理速度，比特币的可拓展性相当受限。</p>
<h3 id="（二）选择可拓展性与安全性"><a href="#（二）选择可拓展性与安全性" class="headerlink" title="（二）选择可拓展性与安全性"></a>（二）选择可拓展性与安全性</h3><p>EOS作为案例。为了解决比特币拓展性的问题，柚子在验证节点的模式上选择了设置21个超级节点，比起比特币的完全分布式验证方式，其处理交易的速度大大提升。但是缺陷就是牺牲了去中心化程度。</p>
<h3 id="（三）选择去中心化与可拓展性"><a href="#（三）选择去中心化与可拓展性" class="headerlink" title="（三）选择去中心化与可拓展性"></a>（三）选择去中心化与可拓展性</h3><p>几乎没有公链选择这样的道路，因为安全性是一切交易和价值的前提。</p>
<p>以太坊被诟病的高gas fee&#x2F;低TPS&#x2F;低扩展性，以及POW的不环保，都将在未来以太坊2.0到来时被改进，然而在2.0彻底到来之前以及之后，Layer2解决方案都可以为以太坊的扩展性提供很多价值。</p>
<h2 id="L2方案对比"><a href="#L2方案对比" class="headerlink" title="L2方案对比"></a>L2方案对比</h2><p>目前四种L2解决方案：状态通道&#x2F;Plasma&#x2F;Zk-Rollup&#x2F;Op-Rollup</p>
<h3 id="状态通道："><a href="#状态通道：" class="headerlink" title="状态通道："></a>状态通道：</h3><p>通过允许在链外（L2）进行X次交易并向网络提交两个交易到链上（L1）来减少第一层的负载和交易成本。这可以通过以下的2个链外交易工作流程实现：</p>
<p>第一个交易打开连接。参与者必须将以太坊的一部分状态锁定在一个多签名合约中。</p>
<p>第二笔交易关闭连接。当交易完成后，提交最后一个链上交易并解锁状态。</p>
<p>通道工作流程可以处理支付（支付通道）或一般状态更新和计算（状态通道）。</p>
<p>通道是在主网上建立即时提款&#x2F;结算的一个伟大的解决方案。此外，它带来了高吞吐量和极低的成本。另一方面，建立和结算通道的时间和成本可能很高，如果成员没有达到有效的退出状态，预计退出时间会很长。</p>
<p>应用项目：Celer Network</p>
<h3 id="（二）Plasma："><a href="#（二）Plasma：" class="headerlink" title="（二）Plasma："></a>（二）Plasma：</h3><p>运算+数据均搬移线下。通过一中心运营商统一汇总所有的交易数据，以一定时期的运算周期为单位，将所有的交易数据提交到eth主链上，并为收款方提供一个账单，收款方可以在当期运算周期结束后随时去运营商处提取款项。缺点是在运营商的运算周期结束前是不可以提现的，使用过polygon的用户都应该有相应体验。</p>
<h3 id="（三）Rollup技术："><a href="#（三）Rollup技术：" class="headerlink" title="（三）Rollup技术："></a>（三）Rollup技术：</h3><p>“Rollups”是在以太坊主网（第二层）之外执行交易的解决方案，交易完成之后，将交易数据送回主网（第一层）。换句话说，Rollups试图从区块链本身卸载交易量，并在一个单独的链上执行交易。<br><img src="/images/1-2.png"></p>
<p>基于Rollup的第2层解决方案有很多好处：</p>
<p><strong>更高的tps和更低的交易费用：</strong>目前以太坊区块链每秒可以处理15–45笔交易。第2层的扩展解决方案将这个数字提升到1000–4000tps。最后，随着ETH 2.0的推出，以太坊区块链有望每秒处理约10万笔交易。更多的tps也意味着更少的网络拥堵。这可能会减少网络上的交易费用。</p>
<p>更快的交易确认：rollups背后的主要想法是将交易量从主区块链中卸载，并在另一层中处理它们。Rollups在第1层部署智能合约，它们负责存款、提款和验证交易。交易确认也可以在批量模式下进行。</p>
<p>更加安全：rollups依赖于以太坊区块链的安全性。因此，他们被认为是更安全的。</p>
<p>现在让我们更详细地讨论不同类型的卷积解决方案。</p>
<h4 id="Optimistic-Rollup"><a href="#Optimistic-Rollup" class="headerlink" title="Optimistic Rollup"></a>Optimistic Rollup</h4><p>Optimistic Rollup使用欺诈证明（fraud proof）。欺诈证明的主要思想是向第1层发送最小数据，并假设（乐观地认为）它是正确的。在交易有效的情况下，区块链不需要做任何事情。如果它是无效的，它必须识别它，回滚状态，并惩罚发件人。<br><img src="/images/1-3.png"><br>为了实现这一点，方案使用了一个 “争议解决系统”。它检测欺诈活动，核实欺诈证明，并抑制不良行为者。为了防止不良行为者向网络发送垃圾交易，发送者还必须提供保证金（通常以ETH的形式）。如果在第一层检测到欺诈活动，这个保证金将被削减作为惩罚。</p>
<p>在Optimistic Rollups中，预计会有很长的提款期（甚至几周）。这主要是因为所有的网络参与者都必须在第1层最终完成交易之前发送证明。另一方面，Optimistic Rollups在开发者之间很受欢迎，主要是因为该技术使用所有现有的以太坊技术栈，几乎没有修改。</p>
<h4 id="ZK-Rollup"><a href="#ZK-Rollup" class="headerlink" title="ZK Rollup"></a>ZK Rollup</h4><p><img src="/images/1-4.png"><br>ZK Rollup使用有效性证明validity proofs。不会存在争议解决方面的问题。相反，它使用一个叫做 “零知识zero-knowledge”的密码学概念。每一个发布到第1层的批次都包括一个叫做 “zk-snark”的加密证明。当交易批次提交时，该证明可以被第1层合约快速验证，无效的交易可以被立即拒绝。不存在提款周期长的问题。然而，由于EVM的兼容性，实施的复杂性要高得多。它们的计算量也比较大。</p>

                
            </div>
        </article>
    
</div>
<div class="side-bar">


    <div class="avator" id="avator">
    <div class="title">
        <a href="#" class="text-underline">About Me</a>
    </div>
        <img src="avator.jpg" class="ava-img">
        <h3 class="author">Leilei</h3>
        <div class="icon-list">
        <a href=""><i class="iconfont icon-weibo icon-item"></i></a>
        <a href="1334274483@qq.com"><i class="iconfont icon-email icon-item"></i></a>
        <a href=""><i class="iconfont icon-github icon-item"></i></a>
        <a href=""><i class="iconfont icon-linkedin icon-item"></i></a>
        </div>
    <div class="tags">
    <h3 class="tags-title">Tags</h3>
    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/StarkNet/" rel="tag">StarkNet</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8AL2/" rel="tag">以太坊L2</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E8%AE%B0/" rel="tag">随记</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8AL3/" rel="tag">以太坊L3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitcoin-Layer2/" rel="tag">Bitcoin Layer2</a><span class="tag-list-count">1</span></li></ul>
</div>
    </div>
</div>

</section>

    <nav class="page-nav">
    
        <a class="prev" href="/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text">上一页</span>
        </a>
    
    
    </nav>



            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="/js/jquery-3.3.1.min.js"></script>

    
<script src="/js/back-to-top.js"></script>

    
<script src="/js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
